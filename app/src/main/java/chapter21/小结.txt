第21章 装饰模式介绍

装饰模式介绍
    装饰模式（Decorator Pattern）也称为包装模式（Wrapper Pattern）,结构型设计模式之一，其使用一种对客户端透明
的方式来动态地扩展对象的功能，同时它也是继承关系的一种替代方案之一。在现实生活中你也可以看见很多装饰模式的例子，
或者可以大胆地说装饰模式无处不在，就拿人来说，人需要各式各样的衣着，不管你穿着怎样，但是，对于个人的本质来说是不变
的，充其量只是在外面披上一层遮羞物而已，者就是装饰模式，装饰物也许各部相同但是装饰的对象本质是不变的。

装饰模式的定义
    动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。

装饰模式使用场景
    需要透明且动态地扩展类的功能时。

角色介绍
    Component：抽象组件。
        可以是一个接口或抽象类，其充当的就是被装饰的原始对象。
    ConcreteComponent：组件具体实现类。
        该类是Component类的基本实现，也是我们装饰的具体对象。
    Decorator：抽象装饰者
        顾名思义，其承担的职责就是为了装饰我们的组件对象，其内部一定要有一个指向组件对象的引用。在大多数情况下，
    该类为抽象类，需要根据不同的装饰逻辑实现不同的具体子类。当然，如果装饰模式单一，只有一个的情况下我们可以省略
    该类直接作为具体的装饰者。
    ConcreteDecoratorA：装饰者具体实现类。
        对抽象装饰者作出具体的实现。
    ConcreteDecoratorB：同上。
    Client：客户类。

小结：

    装饰模式和我们之前所讲到的代理模式有点类似，有时甚至容易混淆，倒不是说回把代理模式当成装饰，而常常会是将装饰
    看作代理，所以大家一定到多留心，装饰模式是对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；
    而代理模式则是给一个对象提供一个代理对象，并有代理对象来控制对原有对象的引用。装饰模式应该为所装饰的对象
    增强功能；代理模式对代理对象施加控制，但不对对象本身的功能进行增强。